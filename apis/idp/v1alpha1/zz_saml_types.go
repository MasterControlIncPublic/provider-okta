/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type SAMLObservation struct {
	AccountLinkAction *string `json:"accountLinkAction,omitempty" tf:"account_link_action,omitempty"`

	AccountLinkGroupInclude []*string `json:"accountLinkGroupInclude,omitempty" tf:"account_link_group_include,omitempty"`

	AcsBinding *string `json:"acsBinding,omitempty" tf:"acs_binding,omitempty"`

	AcsType *string `json:"acsType,omitempty" tf:"acs_type,omitempty"`

	Audience *string `json:"audience,omitempty" tf:"audience,omitempty"`

	DeprovisionedAction *string `json:"deprovisionedAction,omitempty" tf:"deprovisioned_action,omitempty"`

	GroupsAction *string `json:"groupsAction,omitempty" tf:"groups_action,omitempty"`

	GroupsAssignment []*string `json:"groupsAssignment,omitempty" tf:"groups_assignment,omitempty"`

	GroupsAttribute *string `json:"groupsAttribute,omitempty" tf:"groups_attribute,omitempty"`

	GroupsFilter []*string `json:"groupsFilter,omitempty" tf:"groups_filter,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	// Indicates whether Okta uses the original Okta org domain URL, or a custom domain URL
	IssuerMode *string `json:"issuerMode,omitempty" tf:"issuer_mode,omitempty"`

	Kid *string `json:"kid,omitempty" tf:"kid,omitempty"`

	MaxClockSkew *float64 `json:"maxClockSkew,omitempty" tf:"max_clock_skew,omitempty"`

	// Name of the IdP
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NameFormat *string `json:"nameFormat,omitempty" tf:"name_format,omitempty"`

	ProfileMaster *bool `json:"profileMaster,omitempty" tf:"profile_master,omitempty"`

	ProvisioningAction *string `json:"provisioningAction,omitempty" tf:"provisioning_action,omitempty"`

	// The XML digital Signature Algorithm used when signing an <AuthnRequest> message
	RequestSignatureAlgorithm *string `json:"requestSignatureAlgorithm,omitempty" tf:"request_signature_algorithm,omitempty"`

	// Specifies whether to digitally sign <AuthnRequest> messages to the IdP
	RequestSignatureScope *string `json:"requestSignatureScope,omitempty" tf:"request_signature_scope,omitempty"`

	// The minimum XML digital Signature Algorithm allowed when verifying a <SAMLResponse> message or <Assertion> element
	ResponseSignatureAlgorithm *string `json:"responseSignatureAlgorithm,omitempty" tf:"response_signature_algorithm,omitempty"`

	// Specifies whether to verify a <SAMLResponse> message or <Assertion> element XML digital signature
	ResponseSignatureScope *string `json:"responseSignatureScope,omitempty" tf:"response_signature_scope,omitempty"`

	SsoBinding *string `json:"ssoBinding,omitempty" tf:"sso_binding,omitempty"`

	SsoDestination *string `json:"ssoDestination,omitempty" tf:"sso_destination,omitempty"`

	SsoURL *string `json:"ssoUrl,omitempty" tf:"sso_url,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	SubjectFilter *string `json:"subjectFilter,omitempty" tf:"subject_filter,omitempty"`

	SubjectFormat []*string `json:"subjectFormat,omitempty" tf:"subject_format,omitempty"`

	SubjectMatchAttribute *string `json:"subjectMatchAttribute,omitempty" tf:"subject_match_attribute,omitempty"`

	SubjectMatchType *string `json:"subjectMatchType,omitempty" tf:"subject_match_type,omitempty"`

	SuspendedAction *string `json:"suspendedAction,omitempty" tf:"suspended_action,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	UserTypeID *string `json:"userTypeId,omitempty" tf:"user_type_id,omitempty"`

	UsernameTemplate *string `json:"usernameTemplate,omitempty" tf:"username_template,omitempty"`
}

type SAMLParameters struct {

	// +kubebuilder:validation:Optional
	AccountLinkAction *string `json:"accountLinkAction,omitempty" tf:"account_link_action,omitempty"`

	// +kubebuilder:validation:Optional
	AccountLinkGroupInclude []*string `json:"accountLinkGroupInclude,omitempty" tf:"account_link_group_include,omitempty"`

	// +kubebuilder:validation:Optional
	AcsType *string `json:"acsType,omitempty" tf:"acs_type,omitempty"`

	// +kubebuilder:validation:Optional
	DeprovisionedAction *string `json:"deprovisionedAction,omitempty" tf:"deprovisioned_action,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsAction *string `json:"groupsAction,omitempty" tf:"groups_action,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsAssignment []*string `json:"groupsAssignment,omitempty" tf:"groups_assignment,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsAttribute *string `json:"groupsAttribute,omitempty" tf:"groups_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsFilter []*string `json:"groupsFilter,omitempty" tf:"groups_filter,omitempty"`

	// +kubebuilder:validation:Optional
	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	// Indicates whether Okta uses the original Okta org domain URL, or a custom domain URL
	// +kubebuilder:validation:Optional
	IssuerMode *string `json:"issuerMode,omitempty" tf:"issuer_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Kid *string `json:"kid,omitempty" tf:"kid,omitempty"`

	// +kubebuilder:validation:Optional
	MaxClockSkew *float64 `json:"maxClockSkew,omitempty" tf:"max_clock_skew,omitempty"`

	// Name of the IdP
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NameFormat *string `json:"nameFormat,omitempty" tf:"name_format,omitempty"`

	// +kubebuilder:validation:Optional
	ProfileMaster *bool `json:"profileMaster,omitempty" tf:"profile_master,omitempty"`

	// +kubebuilder:validation:Optional
	ProvisioningAction *string `json:"provisioningAction,omitempty" tf:"provisioning_action,omitempty"`

	// The XML digital Signature Algorithm used when signing an <AuthnRequest> message
	// +kubebuilder:validation:Optional
	RequestSignatureAlgorithm *string `json:"requestSignatureAlgorithm,omitempty" tf:"request_signature_algorithm,omitempty"`

	// Specifies whether to digitally sign <AuthnRequest> messages to the IdP
	// +kubebuilder:validation:Optional
	RequestSignatureScope *string `json:"requestSignatureScope,omitempty" tf:"request_signature_scope,omitempty"`

	// The minimum XML digital Signature Algorithm allowed when verifying a <SAMLResponse> message or <Assertion> element
	// +kubebuilder:validation:Optional
	ResponseSignatureAlgorithm *string `json:"responseSignatureAlgorithm,omitempty" tf:"response_signature_algorithm,omitempty"`

	// Specifies whether to verify a <SAMLResponse> message or <Assertion> element XML digital signature
	// +kubebuilder:validation:Optional
	ResponseSignatureScope *string `json:"responseSignatureScope,omitempty" tf:"response_signature_scope,omitempty"`

	// +kubebuilder:validation:Optional
	SsoBinding *string `json:"ssoBinding,omitempty" tf:"sso_binding,omitempty"`

	// +kubebuilder:validation:Optional
	SsoDestination *string `json:"ssoDestination,omitempty" tf:"sso_destination,omitempty"`

	// +kubebuilder:validation:Optional
	SsoURL *string `json:"ssoUrl,omitempty" tf:"sso_url,omitempty"`

	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// +kubebuilder:validation:Optional
	SubjectFilter *string `json:"subjectFilter,omitempty" tf:"subject_filter,omitempty"`

	// +kubebuilder:validation:Optional
	SubjectFormat []*string `json:"subjectFormat,omitempty" tf:"subject_format,omitempty"`

	// +kubebuilder:validation:Optional
	SubjectMatchAttribute *string `json:"subjectMatchAttribute,omitempty" tf:"subject_match_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	SubjectMatchType *string `json:"subjectMatchType,omitempty" tf:"subject_match_type,omitempty"`

	// +kubebuilder:validation:Optional
	SuspendedAction *string `json:"suspendedAction,omitempty" tf:"suspended_action,omitempty"`

	// +kubebuilder:validation:Optional
	UsernameTemplate *string `json:"usernameTemplate,omitempty" tf:"username_template,omitempty"`
}

// SAMLSpec defines the desired state of SAML
type SAMLSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SAMLParameters `json:"forProvider"`
}

// SAMLStatus defines the observed state of SAML.
type SAMLStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SAMLObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SAML is the Schema for the SAMLs API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,okta}
type SAML struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.issuer)",message="issuer is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.kid)",message="kid is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.ssoUrl)",message="ssoUrl is a required parameter"
	Spec   SAMLSpec   `json:"spec"`
	Status SAMLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SAMLList contains a list of SAMLs
type SAMLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SAML `json:"items"`
}

// Repository type metadata.
var (
	SAML_Kind             = "SAML"
	SAML_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SAML_Kind}.String()
	SAML_KindAPIVersion   = SAML_Kind + "." + CRDGroupVersion.String()
	SAML_GroupVersionKind = CRDGroupVersion.WithKind(SAML_Kind)
)

func init() {
	SchemeBuilder.Register(&SAML{}, &SAMLList{})
}
