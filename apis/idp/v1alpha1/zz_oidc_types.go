/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type OidcObservation struct {
	AccountLinkAction *string `json:"accountLinkAction,omitempty" tf:"account_link_action,omitempty"`

	AccountLinkGroupInclude []*string `json:"accountLinkGroupInclude,omitempty" tf:"account_link_group_include,omitempty"`

	AuthorizationBinding *string `json:"authorizationBinding,omitempty" tf:"authorization_binding,omitempty"`

	AuthorizationURL *string `json:"authorizationUrl,omitempty" tf:"authorization_url,omitempty"`

	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	DeprovisionedAction *string `json:"deprovisionedAction,omitempty" tf:"deprovisioned_action,omitempty"`

	GroupsAction *string `json:"groupsAction,omitempty" tf:"groups_action,omitempty"`

	GroupsAssignment []*string `json:"groupsAssignment,omitempty" tf:"groups_assignment,omitempty"`

	GroupsAttribute *string `json:"groupsAttribute,omitempty" tf:"groups_attribute,omitempty"`

	GroupsFilter []*string `json:"groupsFilter,omitempty" tf:"groups_filter,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Indicates whether Okta uses the original Okta org domain URL, custom domain URL, or dynamic. See Identity Provider attributes - issuerMode - https://developer.okta.com/docs/reference/api/idps/#identity-provider-attributes
	IssuerMode *string `json:"issuerMode,omitempty" tf:"issuer_mode,omitempty"`

	IssuerURL *string `json:"issuerUrl,omitempty" tf:"issuer_url,omitempty"`

	JwksBinding *string `json:"jwksBinding,omitempty" tf:"jwks_binding,omitempty"`

	JwksURL *string `json:"jwksUrl,omitempty" tf:"jwks_url,omitempty"`

	MaxClockSkew *float64 `json:"maxClockSkew,omitempty" tf:"max_clock_skew,omitempty"`

	// Name of the IdP
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	ProfileMaster *bool `json:"profileMaster,omitempty" tf:"profile_master,omitempty"`

	ProtocolType *string `json:"protocolType,omitempty" tf:"protocol_type,omitempty"`

	ProvisioningAction *string `json:"provisioningAction,omitempty" tf:"provisioning_action,omitempty"`

	// The HMAC Signature Algorithm used when signing an authorization request
	RequestSignatureAlgorithm *string `json:"requestSignatureAlgorithm,omitempty" tf:"request_signature_algorithm,omitempty"`

	// Specifies whether to digitally sign an authorization request to the IdP
	RequestSignatureScope *string `json:"requestSignatureScope,omitempty" tf:"request_signature_scope,omitempty"`

	Scopes []*string `json:"scopes,omitempty" tf:"scopes,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	SubjectMatchAttribute *string `json:"subjectMatchAttribute,omitempty" tf:"subject_match_attribute,omitempty"`

	SubjectMatchType *string `json:"subjectMatchType,omitempty" tf:"subject_match_type,omitempty"`

	SuspendedAction *string `json:"suspendedAction,omitempty" tf:"suspended_action,omitempty"`

	TokenBinding *string `json:"tokenBinding,omitempty" tf:"token_binding,omitempty"`

	TokenURL *string `json:"tokenUrl,omitempty" tf:"token_url,omitempty"`

	// Type of OIDC IdP.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	UserInfoBinding *string `json:"userInfoBinding,omitempty" tf:"user_info_binding,omitempty"`

	UserInfoURL *string `json:"userInfoUrl,omitempty" tf:"user_info_url,omitempty"`

	UserTypeID *string `json:"userTypeId,omitempty" tf:"user_type_id,omitempty"`

	UsernameTemplate *string `json:"usernameTemplate,omitempty" tf:"username_template,omitempty"`
}

type OidcParameters struct {

	// +kubebuilder:validation:Optional
	AccountLinkAction *string `json:"accountLinkAction,omitempty" tf:"account_link_action,omitempty"`

	// +kubebuilder:validation:Optional
	AccountLinkGroupInclude []*string `json:"accountLinkGroupInclude,omitempty" tf:"account_link_group_include,omitempty"`

	// +kubebuilder:validation:Optional
	AuthorizationBinding *string `json:"authorizationBinding,omitempty" tf:"authorization_binding,omitempty"`

	// +kubebuilder:validation:Optional
	AuthorizationURL *string `json:"authorizationUrl,omitempty" tf:"authorization_url,omitempty"`

	// +kubebuilder:validation:Optional
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSecretSecretRef v1.SecretKeySelector `json:"clientSecretSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	DeprovisionedAction *string `json:"deprovisionedAction,omitempty" tf:"deprovisioned_action,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsAction *string `json:"groupsAction,omitempty" tf:"groups_action,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsAssignment []*string `json:"groupsAssignment,omitempty" tf:"groups_assignment,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsAttribute *string `json:"groupsAttribute,omitempty" tf:"groups_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupsFilter []*string `json:"groupsFilter,omitempty" tf:"groups_filter,omitempty"`

	// Indicates whether Okta uses the original Okta org domain URL, custom domain URL, or dynamic. See Identity Provider attributes - issuerMode - https://developer.okta.com/docs/reference/api/idps/#identity-provider-attributes
	// +kubebuilder:validation:Optional
	IssuerMode *string `json:"issuerMode,omitempty" tf:"issuer_mode,omitempty"`

	// +kubebuilder:validation:Optional
	IssuerURL *string `json:"issuerUrl,omitempty" tf:"issuer_url,omitempty"`

	// +kubebuilder:validation:Optional
	JwksBinding *string `json:"jwksBinding,omitempty" tf:"jwks_binding,omitempty"`

	// +kubebuilder:validation:Optional
	JwksURL *string `json:"jwksUrl,omitempty" tf:"jwks_url,omitempty"`

	// +kubebuilder:validation:Optional
	MaxClockSkew *float64 `json:"maxClockSkew,omitempty" tf:"max_clock_skew,omitempty"`

	// Name of the IdP
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ProfileMaster *bool `json:"profileMaster,omitempty" tf:"profile_master,omitempty"`

	// +kubebuilder:validation:Optional
	ProtocolType *string `json:"protocolType,omitempty" tf:"protocol_type,omitempty"`

	// +kubebuilder:validation:Optional
	ProvisioningAction *string `json:"provisioningAction,omitempty" tf:"provisioning_action,omitempty"`

	// The HMAC Signature Algorithm used when signing an authorization request
	// +kubebuilder:validation:Optional
	RequestSignatureAlgorithm *string `json:"requestSignatureAlgorithm,omitempty" tf:"request_signature_algorithm,omitempty"`

	// Specifies whether to digitally sign an authorization request to the IdP
	// +kubebuilder:validation:Optional
	RequestSignatureScope *string `json:"requestSignatureScope,omitempty" tf:"request_signature_scope,omitempty"`

	// +kubebuilder:validation:Optional
	Scopes []*string `json:"scopes,omitempty" tf:"scopes,omitempty"`

	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// +kubebuilder:validation:Optional
	SubjectMatchAttribute *string `json:"subjectMatchAttribute,omitempty" tf:"subject_match_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	SubjectMatchType *string `json:"subjectMatchType,omitempty" tf:"subject_match_type,omitempty"`

	// +kubebuilder:validation:Optional
	SuspendedAction *string `json:"suspendedAction,omitempty" tf:"suspended_action,omitempty"`

	// +kubebuilder:validation:Optional
	TokenBinding *string `json:"tokenBinding,omitempty" tf:"token_binding,omitempty"`

	// +kubebuilder:validation:Optional
	TokenURL *string `json:"tokenUrl,omitempty" tf:"token_url,omitempty"`

	// +kubebuilder:validation:Optional
	UserInfoBinding *string `json:"userInfoBinding,omitempty" tf:"user_info_binding,omitempty"`

	// +kubebuilder:validation:Optional
	UserInfoURL *string `json:"userInfoUrl,omitempty" tf:"user_info_url,omitempty"`

	// +kubebuilder:validation:Optional
	UsernameTemplate *string `json:"usernameTemplate,omitempty" tf:"username_template,omitempty"`
}

// OidcSpec defines the desired state of Oidc
type OidcSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OidcParameters `json:"forProvider"`
}

// OidcStatus defines the observed state of Oidc.
type OidcStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OidcObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Oidc is the Schema for the Oidcs API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,okta}
type Oidc struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.authorizationBinding)",message="authorizationBinding is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.authorizationUrl)",message="authorizationUrl is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.clientId)",message="clientId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.clientSecretSecretRef)",message="clientSecretSecretRef is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.issuerUrl)",message="issuerUrl is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.jwksBinding)",message="jwksBinding is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.jwksUrl)",message="jwksUrl is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.scopes)",message="scopes is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.tokenBinding)",message="tokenBinding is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.tokenUrl)",message="tokenUrl is a required parameter"
	Spec   OidcSpec   `json:"spec"`
	Status OidcStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OidcList contains a list of Oidcs
type OidcList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Oidc `json:"items"`
}

// Repository type metadata.
var (
	Oidc_Kind             = "Oidc"
	Oidc_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Oidc_Kind}.String()
	Oidc_KindAPIVersion   = Oidc_Kind + "." + CRDGroupVersion.String()
	Oidc_GroupVersionKind = CRDGroupVersion.WithKind(Oidc_Kind)
)

func init() {
	SchemeBuilder.Register(&Oidc{}, &OidcList{})
}
