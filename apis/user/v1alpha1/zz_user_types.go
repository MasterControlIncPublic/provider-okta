/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PasswordHashObservation struct {

	// The algorithm used to generate the hash using the password
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// Only required for salted hashes
	Salt *string `json:"salt,omitempty" tf:"salt,omitempty"`

	// Specifies whether salt was pre- or postfixed to the password before hashing
	SaltOrder *string `json:"saltOrder,omitempty" tf:"salt_order,omitempty"`

	// For SHA-512, SHA-256, SHA-1, MD5, This is the actual base64-encoded hash of the password (and salt, if used). This is the Base64 encoded value of the SHA-512/SHA-256/SHA-1/MD5 digest that was computed by either pre-fixing or post-fixing the salt to the password, depending on the saltOrder. If a salt was not used in the source system, then this should just be the the Base64 encoded value of the password's SHA-512/SHA-256/SHA-1/MD5 digest. For BCRYPT, This is the actual radix64-encoded hashed password.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// Governs the strength of the hash and the time required to compute it. Only required for BCRYPT algorithm
	WorkFactor *float64 `json:"workFactor,omitempty" tf:"work_factor,omitempty"`
}

type PasswordHashParameters struct {

	// The algorithm used to generate the hash using the password
	// +kubebuilder:validation:Required
	Algorithm *string `json:"algorithm" tf:"algorithm,omitempty"`

	// Only required for salted hashes
	// +kubebuilder:validation:Optional
	Salt *string `json:"salt,omitempty" tf:"salt,omitempty"`

	// Specifies whether salt was pre- or postfixed to the password before hashing
	// +kubebuilder:validation:Optional
	SaltOrder *string `json:"saltOrder,omitempty" tf:"salt_order,omitempty"`

	// For SHA-512, SHA-256, SHA-1, MD5, This is the actual base64-encoded hash of the password (and salt, if used). This is the Base64 encoded value of the SHA-512/SHA-256/SHA-1/MD5 digest that was computed by either pre-fixing or post-fixing the salt to the password, depending on the saltOrder. If a salt was not used in the source system, then this should just be the the Base64 encoded value of the password's SHA-512/SHA-256/SHA-1/MD5 digest. For BCRYPT, This is the actual radix64-encoded hashed password.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`

	// Governs the strength of the hash and the time required to compute it. Only required for BCRYPT algorithm
	// +kubebuilder:validation:Optional
	WorkFactor *float64 `json:"workFactor,omitempty" tf:"work_factor,omitempty"`
}

type UserObservation struct {

	// User city
	City *string `json:"city,omitempty" tf:"city,omitempty"`

	// User cost center
	CostCenter *string `json:"costCenter,omitempty" tf:"cost_center,omitempty"`

	// User country code
	CountryCode *string `json:"countryCode,omitempty" tf:"country_code,omitempty"`

	// JSON formatted custom attributes for a user. It must be JSON due to various types Okta allows.
	CustomProfileAttributes *string `json:"customProfileAttributes,omitempty" tf:"custom_profile_attributes,omitempty"`

	CustomProfileAttributesToIgnore []*string `json:"customProfileAttributesToIgnore,omitempty" tf:"custom_profile_attributes_to_ignore,omitempty"`

	// User department
	Department *string `json:"department,omitempty" tf:"department,omitempty"`

	// User display name, suitable to show end users
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// User division
	Division *string `json:"division,omitempty" tf:"division,omitempty"`

	// User primary email address
	Email *string `json:"email,omitempty" tf:"email,omitempty"`

	// User employee number
	EmployeeNumber *string `json:"employeeNumber,omitempty" tf:"employee_number,omitempty"`

	// If set to `true`, the user will have to change the password at the next login. This property will be used when user is being created and works only when `password` field is set
	ExpirePasswordOnCreate *bool `json:"expirePasswordOnCreate,omitempty" tf:"expire_password_on_create,omitempty"`

	// User first name
	FirstName *string `json:"firstName,omitempty" tf:"first_name,omitempty"`

	// User honorific prefix
	HonorificPrefix *string `json:"honorificPrefix,omitempty" tf:"honorific_prefix,omitempty"`

	// User honorific suffix
	HonorificSuffix *string `json:"honorificSuffix,omitempty" tf:"honorific_suffix,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// User last name
	LastName *string `json:"lastName,omitempty" tf:"last_name,omitempty"`

	// User default location
	Locale *string `json:"locale,omitempty" tf:"locale,omitempty"`

	// User Okta login
	Login *string `json:"login,omitempty" tf:"login,omitempty"`

	// Manager of User
	Manager *string `json:"manager,omitempty" tf:"manager,omitempty"`

	// Manager ID of User
	ManagerID *string `json:"managerId,omitempty" tf:"manager_id,omitempty"`

	// User middle name
	MiddleName *string `json:"middleName,omitempty" tf:"middle_name,omitempty"`

	// User mobile phone number
	MobilePhone *string `json:"mobilePhone,omitempty" tf:"mobile_phone,omitempty"`

	// User nickname
	NickName *string `json:"nickName,omitempty" tf:"nick_name,omitempty"`

	// User organization
	Organization *string `json:"organization,omitempty" tf:"organization,omitempty"`

	// Specifies a hashed password to import into Okta.
	PasswordHash []PasswordHashObservation `json:"passwordHash,omitempty" tf:"password_hash,omitempty"`

	// When specified, the Password Inline Hook is triggered to handle verification of the end user's password the first time the user tries to sign in
	PasswordInlineHook *string `json:"passwordInlineHook,omitempty" tf:"password_inline_hook,omitempty"`

	// User mailing address
	PostalAddress *string `json:"postalAddress,omitempty" tf:"postal_address,omitempty"`

	// User preferred language
	PreferredLanguage *string `json:"preferredLanguage,omitempty" tf:"preferred_language,omitempty"`

	// User primary phone number
	PrimaryPhone *string `json:"primaryPhone,omitempty" tf:"primary_phone,omitempty"`

	// User online profile (web page)
	ProfileURL *string `json:"profileUrl,omitempty" tf:"profile_url,omitempty"`

	// The raw status of the User in Okta - (status is mapped)
	RawStatus *string `json:"rawStatus,omitempty" tf:"raw_status,omitempty"`

	// User Password Recovery Question
	RecoveryQuestion *string `json:"recoveryQuestion,omitempty" tf:"recovery_question,omitempty"`

	// User secondary email address, used for account recovery
	SecondEmail *string `json:"secondEmail,omitempty" tf:"second_email,omitempty"`

	// Do not populate user roles information (prevents additional API call)
	SkipRoles *bool `json:"skipRoles,omitempty" tf:"skip_roles,omitempty"`

	// User state or region
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The status of the User in Okta - remove to set user back to active/provisioned
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// User street address
	StreetAddress *string `json:"streetAddress,omitempty" tf:"street_address,omitempty"`

	// User default timezone
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`

	// User title
	Title *string `json:"title,omitempty" tf:"title,omitempty"`

	// User employee type
	UserType *string `json:"userType,omitempty" tf:"user_type,omitempty"`

	// User zipcode or postal code
	ZipCode *string `json:"zipCode,omitempty" tf:"zip_code,omitempty"`
}

type UserParameters struct {

	// User city
	// +kubebuilder:validation:Optional
	City *string `json:"city,omitempty" tf:"city,omitempty"`

	// User cost center
	// +kubebuilder:validation:Optional
	CostCenter *string `json:"costCenter,omitempty" tf:"cost_center,omitempty"`

	// User country code
	// +kubebuilder:validation:Optional
	CountryCode *string `json:"countryCode,omitempty" tf:"country_code,omitempty"`

	// JSON formatted custom attributes for a user. It must be JSON due to various types Okta allows.
	// +kubebuilder:validation:Optional
	CustomProfileAttributes *string `json:"customProfileAttributes,omitempty" tf:"custom_profile_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	CustomProfileAttributesToIgnore []*string `json:"customProfileAttributesToIgnore,omitempty" tf:"custom_profile_attributes_to_ignore,omitempty"`

	// User department
	// +kubebuilder:validation:Optional
	Department *string `json:"department,omitempty" tf:"department,omitempty"`

	// User display name, suitable to show end users
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// User division
	// +kubebuilder:validation:Optional
	Division *string `json:"division,omitempty" tf:"division,omitempty"`

	// User primary email address
	// +kubebuilder:validation:Optional
	Email *string `json:"email,omitempty" tf:"email,omitempty"`

	// User employee number
	// +kubebuilder:validation:Optional
	EmployeeNumber *string `json:"employeeNumber,omitempty" tf:"employee_number,omitempty"`

	// If set to `true`, the user will have to change the password at the next login. This property will be used when user is being created and works only when `password` field is set
	// +kubebuilder:validation:Optional
	ExpirePasswordOnCreate *bool `json:"expirePasswordOnCreate,omitempty" tf:"expire_password_on_create,omitempty"`

	// User first name
	// +kubebuilder:validation:Optional
	FirstName *string `json:"firstName,omitempty" tf:"first_name,omitempty"`

	// User honorific prefix
	// +kubebuilder:validation:Optional
	HonorificPrefix *string `json:"honorificPrefix,omitempty" tf:"honorific_prefix,omitempty"`

	// User honorific suffix
	// +kubebuilder:validation:Optional
	HonorificSuffix *string `json:"honorificSuffix,omitempty" tf:"honorific_suffix,omitempty"`

	// User last name
	// +kubebuilder:validation:Optional
	LastName *string `json:"lastName,omitempty" tf:"last_name,omitempty"`

	// User default location
	// +kubebuilder:validation:Optional
	Locale *string `json:"locale,omitempty" tf:"locale,omitempty"`

	// User Okta login
	// +kubebuilder:validation:Optional
	Login *string `json:"login,omitempty" tf:"login,omitempty"`

	// Manager of User
	// +kubebuilder:validation:Optional
	Manager *string `json:"manager,omitempty" tf:"manager,omitempty"`

	// Manager ID of User
	// +kubebuilder:validation:Optional
	ManagerID *string `json:"managerId,omitempty" tf:"manager_id,omitempty"`

	// User middle name
	// +kubebuilder:validation:Optional
	MiddleName *string `json:"middleName,omitempty" tf:"middle_name,omitempty"`

	// User mobile phone number
	// +kubebuilder:validation:Optional
	MobilePhone *string `json:"mobilePhone,omitempty" tf:"mobile_phone,omitempty"`

	// User nickname
	// +kubebuilder:validation:Optional
	NickName *string `json:"nickName,omitempty" tf:"nick_name,omitempty"`

	// Old User Password. Should be only set in case the password was not changed using the provider
	// +kubebuilder:validation:Optional
	OldPasswordSecretRef *v1.SecretKeySelector `json:"oldPasswordSecretRef,omitempty" tf:"-"`

	// User organization
	// +kubebuilder:validation:Optional
	Organization *string `json:"organization,omitempty" tf:"organization,omitempty"`

	// Specifies a hashed password to import into Okta.
	// +kubebuilder:validation:Optional
	PasswordHash []PasswordHashParameters `json:"passwordHash,omitempty" tf:"password_hash,omitempty"`

	// When specified, the Password Inline Hook is triggered to handle verification of the end user's password the first time the user tries to sign in
	// +kubebuilder:validation:Optional
	PasswordInlineHook *string `json:"passwordInlineHook,omitempty" tf:"password_inline_hook,omitempty"`

	// User Password
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// User mailing address
	// +kubebuilder:validation:Optional
	PostalAddress *string `json:"postalAddress,omitempty" tf:"postal_address,omitempty"`

	// User preferred language
	// +kubebuilder:validation:Optional
	PreferredLanguage *string `json:"preferredLanguage,omitempty" tf:"preferred_language,omitempty"`

	// User primary phone number
	// +kubebuilder:validation:Optional
	PrimaryPhone *string `json:"primaryPhone,omitempty" tf:"primary_phone,omitempty"`

	// User online profile (web page)
	// +kubebuilder:validation:Optional
	ProfileURL *string `json:"profileUrl,omitempty" tf:"profile_url,omitempty"`

	// User Password Recovery Answer
	// +kubebuilder:validation:Optional
	RecoveryAnswerSecretRef *v1.SecretKeySelector `json:"recoveryAnswerSecretRef,omitempty" tf:"-"`

	// User Password Recovery Question
	// +kubebuilder:validation:Optional
	RecoveryQuestion *string `json:"recoveryQuestion,omitempty" tf:"recovery_question,omitempty"`

	// User secondary email address, used for account recovery
	// +kubebuilder:validation:Optional
	SecondEmail *string `json:"secondEmail,omitempty" tf:"second_email,omitempty"`

	// Do not populate user roles information (prevents additional API call)
	// +kubebuilder:validation:Optional
	SkipRoles *bool `json:"skipRoles,omitempty" tf:"skip_roles,omitempty"`

	// User state or region
	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The status of the User in Okta - remove to set user back to active/provisioned
	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// User street address
	// +kubebuilder:validation:Optional
	StreetAddress *string `json:"streetAddress,omitempty" tf:"street_address,omitempty"`

	// User default timezone
	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`

	// User title
	// +kubebuilder:validation:Optional
	Title *string `json:"title,omitempty" tf:"title,omitempty"`

	// User employee type
	// +kubebuilder:validation:Optional
	UserType *string `json:"userType,omitempty" tf:"user_type,omitempty"`

	// User zipcode or postal code
	// +kubebuilder:validation:Optional
	ZipCode *string `json:"zipCode,omitempty" tf:"zip_code,omitempty"`
}

// UserSpec defines the desired state of User
type UserSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     UserParameters `json:"forProvider"`
}

// UserStatus defines the observed state of User.
type UserStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        UserObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// User is the Schema for the Users API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,okta}
type User struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.email)",message="email is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.firstName)",message="firstName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.lastName)",message="lastName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.login)",message="login is a required parameter"
	Spec   UserSpec   `json:"spec"`
	Status UserStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// UserList contains a list of Users
type UserList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []User `json:"items"`
}

// Repository type metadata.
var (
	User_Kind             = "User"
	User_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: User_Kind}.String()
	User_KindAPIVersion   = User_Kind + "." + CRDGroupVersion.String()
	User_GroupVersionKind = CRDGroupVersion.WithKind(User_Kind)
)

func init() {
	SchemeBuilder.Register(&User{}, &UserList{})
}
